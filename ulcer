#!/bin/perl
package Ulcer;
use strict;
use warnings FATAL => 'all';

use Data::Dumper;
use Date::Format;
use MCE::Flow;
use MCE::Queue;
use Sys::Statistics::Linux::MemStats;

my $bus = MCE::Queue->new;

my %state;
my @processes;
my %sources;

$sources{time} = sub {
    while () {
        my $now = time();
        $bus->enqueue(+{
                time => {
                    pretty => time2str("%Y-%m-%d %H:%M:%S", $now),
                    seconds => $now,
                }
            }
        );
        sleep 3;
    }
};

$sources{mem} = sub {
    while () {
        my $lxs = Sys::Statistics::Linux::MemStats->new;
        $bus->enqueue(+{ mem => $lxs->get, });
        sleep 10;
    }
};

$sources{acpibat} = sub {
    while () {
        my %vals;
        for my $bat (glob '/sys/class/power_supply/BAT*') {
            my $capacity = file_content("$bat/capacity");
            my $status = file_content("$bat/status");
            $bat =~ s/.*\///;
            $vals{$bat} = {
                capacity => $capacity,
                status => $status,
            };
        }
        $bus->enqueue(+{ bat => \%vals, });
        sleep 20;
    }
};

$sources{hlwm} = sub {
    sub tags_raw {
        my $raw_tags = `herbstclient tag_status`;
        $raw_tags =~ s/^\s+//;
        $raw_tags =~ s/\s+$//;
        split /\s+/, $raw_tags;
    }

    sub tags {
        map {
            (my $name = $_) =~ s/^.//;
            $name;
        } tags_raw();
    }

    $bus->enqueue(+{ 'hlwm.tags.list' => join (" ", tags) });

    my @tags = tags_raw;
    open my $hc_stdout, "herbstclient --idle |";
    while (my $line = <$hc_stdout>) {
        chop $line;
        my ($event, $tag, $arg) = split /\t/, $line;
        if ($event eq "tag_changed") {
            $bus->enqueue(+{
                    hlwm => {
                        'tags.active' => $tag,
                        event => {
                            raw => $line,
                            name => $event,
                        }
                    },
                });
        } elsif ($event eq "focus_changed" || $event eq "window_title_changed") {
            $bus->enqueue(+{
                    'hlwm.window.title' => $arg,
                });
        } elsif ($event eq "urgent") {
            my @urgent_tags = map {
                (my $name = $_) =~ s/^.//;
                $name;
            } grep /^!/, tags_raw;

            $bus->enqueue(+{ 'hlwm.tags.urgent' => join(" ", @urgent_tags) });
        }
    }
    close $hc_stdout;
};

sub file_content {
    my ($file) = @_;

    my $content = do { local( @ARGV, $/ ) = $file; <> };
    chomp $content;
    $content;
}

sub flatten {
    my ($h, $prefix) = @_;

    if (ref $h eq 'HASH') {
        my @subs = map {
            flatten($h->{$_}, $prefix . '.' . $_)->%*
        } keys $h->%*;

        return +{ @subs };
    }

    return +{ $prefix => $h };
}

sub display {
    my ($v, $s) = @_;

    my $target = $s;
    while ($s =~ /\$\{(\.[^\}]+)+\}/g) {
        my $key = $1;
        my $repl = "\\\$\\\{$key\\\}";
        if (defined $v->{$key}) {
            $target =~ s/$repl/$v->{$key}/;
        } elsif ($key eq ".state") {
            print Dumper(\%state);
            return;
        } else {
            $target =~ s/$repl//;
        }
    }
    print $target . "\n";
}

push @processes, sub {
    my $events = 0;
    my $loops = 0;

    while () {
        my $iter = 0;
        do {
            my $event = $bus->dequeue;
            %state = (%state, flatten($event, "")->%*);
            $events++;
        } while ($bus->pending && $iter++ < 100);

        $state{".ulcer.events"} = $events;
        $state{".ulcer.loops"} = ++$loops;

        display(\%state, $ARGV[0]);
    }
};

die "Usage: $0 <formatstring> <list-of-sources>" unless defined $ARGV[1];

for my $as (split /\s*,\s*/, $ARGV[1]) {
    if (defined (my $source = $sources{$as})) {
        push @processes, $source;
    }
}

mce_flow {max_workers => 1}, @processes;
