#!/bin/perl
package Ulcer;
use strict;
use warnings FATAL => 'all';

use Data::Dumper;
use Date::Format;
use MCE::Flow;
use MCE::Queue;
use Sys::Statistics::Linux::MemStats;

my $bus = MCE::Queue->new;

my %state;
my @processes;
my %sources;

$sources{time} = sub {
    while () {
        my $now = time();
        $bus->enqueue(+{
                time => {
                    pretty => time2str("%Y-%m-%d %H:%M:%S", $now),
                    seconds => $now,
                }
            }
        );
        sleep 3;
    }
};

$sources{mem} = sub {
    while () {
        my $lxs = Sys::Statistics::Linux::MemStats->new;
        $bus->enqueue(+{ mem => $lxs->get, });
        sleep 10;
    }
};

$sources{acpibat} = sub {
    while () {
        my %vals;
        for my $bat (glob '/sys/class/power_supply/BAT*') {
            my $capacity = file_content("$bat/capacity");
            my $status = file_content("$bat/status");
            $bat =~ s/.*\///;
            $vals{$bat} = {
                capacity => $capacity,
                status => $status,
            };
        }
        $bus->enqueue(+{ bat => \%vals, });
        sleep 20;
    }
};

$sources{hlwm} = sub {
    sub tags_raw {
        my $raw_tags = `herbstclient tag_status`;
        $raw_tags =~ s/^\s+//;
        $raw_tags =~ s/\s+$//;
        split /\s+/, $raw_tags;
    }

    sub tags {
        map {
            (my $name = $_) =~ s/^.//;
            $name;
        } tags_raw();
    }

    sub tag_status {
        map {
            (my $status = $_) =~ s/^(.).+/$1/;
            (my $name = $_) =~ s/^.//;

            if ($status eq '#') {
                "[$name]";
            } elsif ($status eq ':') {
                ".$name.";
            } else {
                " $name ";
            }
        } tags_raw();
    }

    $bus->enqueue(+{ 'hlwm.tags.list' => join (" ", tags) });

    my @tags = tags_raw;
    open my $hc_stdout, "herbstclient --idle tag_changed |";
    while (my $line = <$hc_stdout>) {
        chop $line;
        my ($event, $tag, $monitor) = split /\t/, $line;
        $bus->enqueue(+{
                hlwm => {
                    'tags.active' => $tag,
                    event => {
                        raw => $line,
                        name => $event,
                    }
                },
            });
    }
};

sub file_content {
    my ($file) = @_;

    open my $f, $file or die;
    my $content = <$f>;
    close $f;

    chomp $content;
    $content;
}

sub flatten {
    my ($h, $prefix) = @_;

    if (ref $h eq 'HASH') {
        my @subs = map {
            flatten($h->{$_}, $prefix . '.' . $_)->%*
        } keys $h->%*;

        return +{ @subs };
    }

    return +{ $prefix => $h };
}

sub display {
    my ($v, $s) = @_;

    my $target = $s;
    while ($s =~ /\$\{(\.[^\}]+)+\}/g) {
        my $key = $1;
        my $repl = "\\\$\\\{$key\\\}";
        if (defined $v->{$key}) {
            $target =~ s/$repl/$v->{$key}/;
        } elsif ($key eq ".state") {
            print Dumper(\%state);
            return;
        }
    }
    print $target . "\n";
}

push @processes, sub {
    my $events = 0;
    my $loops = 0;

    while () {
        my $iter = 0;
        do {
            my $event = $bus->dequeue;
            %state = (%state, flatten($event, "")->%*);
            $events++;
        } while ($bus->pending && $iter++ < 100);

        $state{".ulcer.events"} = $events;
        $state{".ulcer.loops"} = ++$loops;

        display(\%state, $ARGV[0]);
    }
};

die "Usage: $0 <formatstring> <list-of-sources>" unless defined $ARGV[1];

for my $as (split /\s*,\s*/, $ARGV[1]) {
    if (defined (my $source = $sources{$as})) {
        push @processes, $source;
    }
}

mce_flow {max_workers => 1}, @processes;
