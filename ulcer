#!/bin/perl
package Ulcer;
use strict;
use warnings FATAL => 'all';

use Data::Dumper;
use Date::Format;
use MCE::Hobo;
use MCE::Shared;
use Safe;
use Sys::Statistics::Linux::MemStats;

my $bus = MCE::Shared->queue();

my @jobs;
my %sources;

$sources{time} = sub {
    while () {
        my $now = time();
        $bus->enqueue(+{
                time => {
                    pretty => time2str("%Y-%m-%d %H:%M:%S", $now),
                    seconds => $now,
                }
            }
        );
        sleep 3;
    }
};

$sources{mem} = sub {
    my $lxs = Sys::Statistics::Linux::MemStats->new;
    while () {
        $bus->enqueue(+{ mem => $lxs->get });
        sleep 10;
    }
};

$sources{acpi} = sub {
    while () {
        my %batvals;
        {
            for my $bat (glob '/sys/class/power_supply/BAT*') {
                my $capacity = file_content("$bat/capacity");
                my $status = file_content("$bat/status");
                $batvals{$bat =~ s/.*\///r} = {
                    capacity => $capacity,
                    status => $status,
                };
            }
        }

        my %tempvals;
        {
            for my $zone (glob '/sys/class/thermal/thermal_zone*') {
                my $temp = file_content("$zone/temp");
                $tempvals{$zone =~ s/.*\///r} = { temp => $temp / 1000 };
            }
        }
        $bus->enqueue(+{
                bat => \%batvals,
                temp => \%tempvals,
            });

        sleep 20;
    }
};

$sources{hlwm} = sub {
    sub tags_raw {
        my $raw_tags = `herbstclient tag_status`;
        $raw_tags =~ s/^\s+//;
        $raw_tags =~ s/\s+$//;
        split /\s+/, $raw_tags;
    }

    sub tags { map { s/^.//r } tags_raw(); }

    $bus->enqueue(+{ 'hlwm.tags.list' => join (" ", tags) });

    my @tags = tags_raw;
    open my $hc_stdout, "herbstclient --idle |";
    while (my $line = <$hc_stdout>) {
        chop $line;
        my ($event, $tag, $arg) = split /\t/, $line;
        if ($event eq "tag_changed") {
            $bus->enqueue(+{
                    hlwm => {
                        'tags.active' => $tag,
                        event => {
                            raw => $line,
                            name => $event,
                        }
                    },
                });
        } elsif ($event eq "focus_changed" || $event eq "window_title_changed") {
            $bus->enqueue(+{ 'hlwm.window.title' => $arg });
        } elsif ($event eq "urgent") {
            my @urgent_tags = map { s/^.//r } grep /^!/, tags_raw;

            $bus->enqueue(+{ 'hlwm.tags.urgent' => join(" ", @urgent_tags) });
        }
    }
    close $hc_stdout;
};

sub file_content {
    my ($file) = @_;

    my $content = do { local( @ARGV, $/ ) = $file; <> };
    chomp $content;
    $content;
}

sub flatten {
    my ($h, $prefix) = @_;

    if (ref $h eq 'HASH') {
        my @subs = map {
            flatten($h->{$_}, $prefix . '.' . $_)->%*
        } keys $h->%*;

        return +{ @subs };
    }

    return +{ $prefix => $h };
}

sub display {
    my ($v, $s) = @_;

    my $target = $s;
    while ($s =~ /
        (?<all>
            # The entire block matches placeholders like ${name} or, more fancy,
            # ${name|`out conversion`}
            # The pipe and the out conversion in backticks are optional, but
            # the name is mandatory.
            \$\{
                # The name may contain any character but } or | which would
                # both terminate the name part
                (?<name>[^ \} \| ]+)+

                # The optional out conversion part starts with a pipe and
                # encloses an out conversion in backticks. We use the backticks
                # so that }  is allowed in the conversion.
                (\|`(?<outconv>[^`]*)`)?
            \}
        )
    /gxx) {
        my $repl = quotemeta($+{all});
        if (defined $v->{$+{name}}) {
            my $actual;
            if (defined $+{outconv}) {
                my $safe = new Safe;
                ${$safe->varglob('val')} = $v->{$+{name}};
                $actual = $safe->reval($+{outconv});
            } else {
                $actual = $v->{$+{name}};
            };
            $target =~ s/$repl/$actual/;
        } elsif ($+{name} eq ".state") {
            print Dumper($v);
            return;
        } else {
            $target =~ s/$repl//;
        }
    }
    print $target . "\n";
}

sub collector {
    my $events = 0;
    my $loops = 0;
    my %state;

    $state{".ulcer.plugins"} = join(", ", keys %sources);

    while () {
        my $iter = 0;
        do {
            my $event = $bus->dequeue;
            %state = (%state, flatten($event, "")->%*);
            $events++;
        } while ($bus->pending && $iter++ < 100);

        $state{".ulcer.events"} = $events;
        $state{".ulcer.loops"} = ++$loops;

        display(\%state, $ARGV[0]);
    }
};

die "Usage: $0 <formatstring> <list-of-sources>" unless defined $ARGV[1];

push @jobs, map { $sources{$_} // () } split /\s*,\s*/, $ARGV[1];

my @hobos = map { MCE::Hobo->new($_); } @jobs;
my $collector_hobo = MCE::Hobo->new(\&collector);

$collector_hobo->join();
for my $hobo (@hobos) {
    $hobo->join();
}
